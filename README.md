# Грокаем алгоритмы 

# Первая задача  Binary Search


```
Бинарный поиск - алгоритм, который решает задачу поиска, 
например, ищет нужную фамилию в телефонном справочнике 
или зарегистрированного пользователя в базе данных.

Бинарный поиск - алгоритм поиска элемента в отсортированном списке.
Если искомый элемент находится в списке, алгоритм возвращает его индекс(позицию).
Иначе вернет null.
```
Пример - угадай загаданное от 1 до 100 число.

```
Можно использовать тупой поиск и перечислять каждое число по порядку, однако, это неэффективный случай, 
потому что в худшем случае это займет 100 попыток.
Бинарный же поиск - наиболее эффективный алгоритм, вы же не станете искать номер телефона человека 
с фамилией на букву К с самого начала справочника, вы откроете его где-нибудь на середине, 
чтобы быстрее оказаться на букве К. 

Так и бинарный поиск отбрасывает ненужные для поиска элементы, сокращая список. Он каждый раз выбирает 
элемент в середине списка, чтобы отбросить одну или вторую половину. Таким образом, 
отгадывая число из 100, задачу можно решить за 7 шагов, используя бинарный поиск.
```

Что нужно сделать?
```
1. Написать код бинарного поиска.
2. Сделать передачу списка (сортированного) и числа через параметры.
3. Выполнить сортировку списка, если передан неотсортированный список.
4. Написать тесты.
```

Как работает алгоритм?
```
Функция binary_search принимает отсортированный список и элемент, который нужно найти.
Первое, что делаем задаем границы поиска, это будут индексы первого и последнего элемента списка.
Каждый итерацию проверяем элемент посередине списка поиска: находим его индекс и сравниваем с заданным числом.
Если определенное число больше, чем заданное, тогда сдвигаем верхнюю границу поиска, 
Иначе сдвигаем нижнюю.
```
 Запуск скрипта с параметрами
```
python binarySearch.py --list 1 3 5 7 9  --item 3
```

# Вторая задача - Сортировка выбором

Массивы и Связанные списки
```
Чтобы сохранить несколько элементов в памяти компьютера используются массивы и списки.

* При использовании массива все элементы будут храниться в памяти рядом друг с другом,
потому чтобы сохранить массив нужно найти столько пустых ячеек памяти рядом, сколько 
элементов в массиве. 

* При использовании списка же такого не требуется, элементы могут занимать любое свободное
место в памяти, держа адрес ячейки, в которой сохранен следующий элемент.

Недостатком массива является то, что при добавлении нового элемента нужно искать группу 
свободных ячеек в памяти, чтобы сохранить этот массив. Поэтому можно делать бронирование 
дополнительных ячеек памяти, но они не всегда могут быть использованы, а это приводит к нерациональному
использованию памяти.

В спиках такого нет, элемент запишется в любую свободную ячейку, а ее адрес сохранится в предыдущем элементе.

Однако, массив удобнее при обращении к элементу, мы за одну операцию можем обратиться к любому его элементу.
Со списком такое не пройдет, потому что мы не знаем, где лежит этот элемент и нам надо по порядку пройти 
все элементы перед нужным, чтобы до него добраться.
```

Вставка в середину и удаление
```
Списки больше подходят для вставки элемента в середину. При этом нужно просто перезаписать адрес на ячейку 
в предыдущем элементе.
В массиве же приходится сдвигать все последующие элементы.

Для удаления также списки лучше подходят, тут тоже суть заключается в перезаписи адреса.
```

Сортировка выбором
```
Суть заключается в том, чтобы пробегать по элементам, находить нужный и перемещать его в новый список.
Например, нужно отсортировать учеников по количеству прогулов от большего к меньшему.
Идем по списку, находим ученика с наибольшим количеством пропусков и переносим его в новый список.
Затем повторяем то же самое, пока не закончится перввый список. В итоге получим новый - отсортированный.
```

Задача
```
Написать алгоритм сортировки массива чисел от меньшего к большему
```

Что нужно сделать?
```
1. Написать функцию - поиска наименьшего элемента.
2. Написать функцию сортировки, используя первую.
3. Сделать передачу списка через параметры.
```